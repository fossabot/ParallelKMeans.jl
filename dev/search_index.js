var documenterSearchIndex = {"docs":
[{"location":"#ParallelKMeans.jl-1","page":"Home","title":"ParallelKMeans.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [ParallelKMeans]","category":"page"},{"location":"#ParallelKMeans.kmeans-Union{Tuple{T}, Tuple{Array{Float64,2},Int64}, Tuple{Array{Float64,2},Int64,T}} where T<:ParallelKMeans.CalculationMode","page":"Home","title":"ParallelKMeans.kmeans","text":"Kmeans(design_matrix, k; k_init=\"k-means++\", max_iters=300, tol=1e-4, verbose=true)\n\nThis main function employs the K-means algorithm to cluster all examples in the training data (design_matrix) into k groups using either the k-means++ or random initialisation technique for selecting the initial centroids.\n\nAt the end of the number of iterations specified (max_iters), convergence is achieved if difference between the current and last cost objective is less than the tolerance level (tol). An error is thrown if convergence fails.\n\nDetails of operations can be either printed or not by setting verbose accordingly.\n\nA tuple representing labels, centroids, and sum_squares respectively is returned.\n\n\n\n\n\n","category":"method"},{"location":"#ParallelKMeans.divider-Tuple{Any,Any}","page":"Home","title":"ParallelKMeans.divider","text":"divider(n, k)\n\nUtility function, splits 1:n sequence to k chunks of approximately same size.\n\n\n\n\n\n","category":"method"},{"location":"#ParallelKMeans.inner_pairwise!-NTuple{4,Any}","page":"Home","title":"ParallelKMeans.inner_pairwise!","text":"inner_pairwise!(target, x, y, r)\n\nUtility function for calculation of pairwise!(target, x, y, mode) function. UnitRange argument r select subarray of original design matrix x that is going to be processed.\n\n\n\n\n\n","category":"method"},{"location":"#ParallelKMeans.pairwise!-Tuple{Any,Any,Any}","page":"Home","title":"ParallelKMeans.pairwise!","text":"pairwise!(target, x, y, mode)\n\nLet X and Y respectively have m and n columns. Then the pairwise! function computes distances between each pair of columns in X and Y and store result in target array. Argument mode defines calculation mode, currently following modes supported\n\nSingleThread()\nMultiThread()\n\n\n\n\n\n","category":"method"},{"location":"#ParallelKMeans.smart_init-Union{Tuple{T}, Tuple{Array{Float64,2},Int64}, Tuple{Array{Float64,2},Int64,T}} where T<:ParallelKMeans.CalculationMode","page":"Home","title":"ParallelKMeans.smart_init","text":"smart_init(X, k; init=\"k-means++\")\n\nThis function handles the random initialisation of the centroids from the design matrix (X) and desired groups (k) that a user supplies.\n\nk-means++ algorithm is used by default with the normal random selection of centroids from X used if any other string is attempted.\n\nA tuple representing the centroids, number of rows, & columns respecitively is returned.\n\n\n\n\n\n","category":"method"},{"location":"#ParallelKMeans.sum_of_squares-Tuple{Array{Float64,2},Array{Int64,1},Array}","page":"Home","title":"ParallelKMeans.sum_of_squares","text":"sum_of_squares(x, labels, centre, k)\n\nThis function computes the total sum of squares based on the assigned (labels) design matrix(x), centroids (centre), and the number of desired groups (k).\n\nA Float type representing the computed metric is returned.\n\n\n\n\n\n","category":"method"}]
}
